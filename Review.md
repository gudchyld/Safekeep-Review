## SafeKeep VaultSpawnerFacet

Vaults are smart contracts that help users find the best yield on their crypto tokens through the execution of different strategies. These vaults can accept various token protocols whether fungible or non-fungible as designed.

In the Context of Safekeep, the safekeep vault is a form of onchain will where user can store assets such as ERC20, ERC721 and ERC1155 variants. Safekeep utilizes a register of inheritors that can become beneficiaries in the situation where a user passes on.

The Safekeep VaultSpawnerFacet is a factory for the safekeep vault that simply deploys safekeep vaults

##### Line 1

`pragma solidity 0.8.4`
This defines the version of compiler to use for this project

##### Line 3-9

```
import "../../Vault/VaultDiamond.sol";
import "../libraries/LibAppStorage.sol";
import "../../Vault/libraries/LibKeep.sol";
import "../../interfaces/IVaultDiamond.sol";

import "../../interfaces/IDiamondCut.sol";
import "../../interfaces/IVaultFacet.sol";
```

This defines imports of libraries, interfaces, storage, and the VaultDiamond to be used in this contract

##### Line 11

```
contract VaultSpawnerFacet is StorageLayout {
```

The contract keyword defines a contract VaultSpawnerFacet which inherits from an abstract contract called StorageLayout that declares a pointer to a FactoryAppStorage which is a container that houses the variables to be used in this contract

##### Line 12

```
event VaultCreated(
    address indexed owner,
    address indexed backup,
    uint256 indexed startingBalance,
    uint256 vaultID
  );
```

This declares an event to be emitted when a new vault is created, emitting the owner of the vaults address, his backup address, his starting balance and the id of the created vault

##### Line 19

```
error BackupAddressError()
```

This defines a custom error message BackupAddressError()

##### Line 21

```
  function createVault(
    address[] calldata _inheritors,
    uint256[] calldata _weiShare,
    uint256 _startingBal,
    address _backupAddress
  ) external payable returns (address addr) {
```

The createvault function is called when a new vault is to created, it is declared as external denoting that it can only be called by an external source and payable
Which enables the contract to receive ether values and returns an address.
It takes in 4 parameters;
An array of inheritors addresses
An array of shares in wei to be ascribed to each inheritor
A starting balance to populate the vault and
A backup address for safety measures

##### Line 27

```
if (_backupAddress == msg.sender){
 revert BackupAddressError();
}
```

This ensures that the address interacting with this function is not the same as the provided address
It reverts with a BackupAddressError if the condition is true

##### Line 30

```
if (_startingBal > 0) {
      assert(_startingBal == msg.value);
    }
```

This line defines a condition that asserts that the starting balance is equivalent to the value coming in from the user if the starting balance is greater than zero

##### Line 33

```
assert(_inheritors.length == _weiShare.length);
```

This line ensures that the length of the inheritors array is equivalent to the length of the array holding the individual weiShare. it reverts if false

##### Line 35 - 42

```
bytes32 entropy = keccak256(
      abi.encode(msg.sender, block.timestamp, fs.VAULTID)
    );
 VaultDiamond vaultAddr = new VaultDiamond{ salt: entropy }(
      fs.diamondCutFacet,
      _backupAddress
    );
addr = address(vaultAddr);
```

This lines deploys an instance of a vaultdiamond to an address (vaultAddr) and ensures that the entropy is unique which is a random 32 byte value generated by hashing the encoded result of msg.sender, block.timestamp and the vaultid, then finally passing the returned address to the variable "addr".

##### Line 46 - 49

```
assert(IVaultDiamond(addr).tempOwner() == tx.origin);
    //deposit startingBal
(bool success, ) = addr.call{ value: _startingBal }("");
    assert(success)
```

asserts that the owner of the deployed vault is an Externally Owned Contract(EOA)
then proceed to deposit a value which is the passed in starting balance which should return a true or false
state depending on the success of the call
then finally ensures that a value of 1(true) is returned else it reverts

## UPGRADING

##### Line 52

```
 IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](6)
```

This line creates a fixed array(length is six) of FacetCut Struct called "cut" as defined in the IDiamondCut interface. This struct is a container for the facetAddress, The action to be performed on that facet and an array of the facet functions to be added to the diamond.

##### Line 53 - 57

```
cut[0] = IDiamondCut.FacetCut({
      facetAddress: fs.erc20Facet,
      action: IDiamondCut.FacetCutAction.Add,
      functionSelectors: fs.ERC20SELECTORS
    })
```

This initializes a struct at index 0 of the cut array, this struct has its facetAddress set to the erc20Facet, together with the functions to be added(an add action, gotten from an enumerable of FacetCutActions which comprises of Add, Replace and Remove actions)

##### Line 58 - 62

```
 cut[1] = IDiamondCut.FacetCut({
      facetAddress: fs.erc721Facet,
      action: IDiamondCut.FacetCutAction.Add,
      functionSelectors: fs.ERC721SELECTORS
    })
```

This initializes a struct at index 1 of the cut array, this struct has its facetAddress set to the erc721Facet, together with the functions to be added(an add action, gotten from an enumerable of FacetCutActions which comprises of Add, Replace and Remove actions)

##### Line 63 - 67

```
 cut[2] = IDiamondCut.FacetCut({
      facetAddress: fs.erc1155Facet,
      action: IDiamondCut.FacetCutAction.Add,
      functionSelectors: fs.ERC1155SELECTORS
    })
```

This initializes a struct at index 2 of the cut array, this struct has its facetAddress set to the erc1155Facet, together with the functions to be added(an add action, gotten from an enumerable of FacetCutActions which comprises of Add, Replace and Remove actions)

##### Line 68 - 72

```
cut[3] = IDiamondCut.FacetCut({
      facetAddress: fs.diamondLoupeFacet,
      action: IDiamondCut.FacetCutAction.Add,
      functionSelectors: fs.DIAMONDLOUPEFACETSELECTORS
    })
```

This initializes a struct at index 3 of the cut array, this struct has its facetAddress set to the diamondLoupeFacet, together with the functions to be added(an add action, gotten from an enumerable of FacetCutActions which comprises of Add, Replace and Remove actions)

##### Line 73 - 77

```
cut[4] = IDiamondCut.FacetCut({
      facetAddress: fs.vaultFacet,
      action: IDiamondCut.FacetCutAction.Add,
      functionSelectors: fs.VAULTFACETSELECTORS
    })
```

This initializes a struct at index 4 of the cut array, this struct has its facetAddress set to the vaultFacet, together with the functions to be added(an add action, gotten from an enumerable of FacetCutActions which comprises of Add, Replace and Remove actions)

##### Line 79 - 83

```
cut[5] = IDiamondCut.FacetCut({
      facetAddress: fs.slotChecker,
      action: IDiamondCut.FacetCutAction.Add,
      functionSelectors: fs.SLOTCHECKERSELECTORS
    })
```

This initializes a struct at index 5 of the cut array, this struct has its facetAddress set to the slotChecker, together with the functions to be added(an add action, gotten from an enumerable of FacetCutActions which comprises of Add, Replace and Remove actions)

##### Line 85

```
IDiamondCut(addr).diamondCut(cut, address(0), "")
```

This performs a call to the diamondCut function using an interface IDiamondCut on the vaultdiamond
passing in an array of FacetCut, a zero address with no calldata. This executes the upgrade

##### 87 - 89

```if (_inheritors.length > 0) {
      IVaultFacet(addr).addInheritors(_inheritors, _weiShare);
    }
```

This line checks to ensure that the number of inheritors passed with the createVault function call is greater than zero.
if the condition is true, the inheritors addresses are added to the array of inheritors as declared in the VaultData storage

##### Line 91 - 92

```
 emit VaultCreated(msg.sender, _backupAddress, _startingBal, fs.VAULTID);
    fs.VAULTID++
```

The vaultCreated event finally emits the msg.sender, the backupAddress, the starting balance and the ID of the Vault.

Finally the Vault ID is incremented by one
