## SafeKeep VaultSpawnerFacet

Vaults are smart contracts that help users find the best yield on their crypto tokens through the execution of different strategies. These vaults can accept various token protocols whether fungible or non-fungible as designed.

In the Context of Safekeep, the safekeep vault is a form of onchain will where user can store assets such as ERC20, ERC721 and ERC1155 variants. Safekeep utilizes a register of inheritors that can become beneficiaries in the situation where a user passes on.

The Safekeep VaultSpawnerFacet is a factory for the safekeep vault that simply deploys safekeep vaults

##### Line 1

`pragma solidity 0.8.4`
This defines the version of compiler to use for this project

##### Line 3-9

```
import "../../Vault/VaultDiamond.sol";
import "../libraries/LibAppStorage.sol";
import "../../Vault/libraries/LibKeep.sol";
import "../../interfaces/IVaultDiamond.sol";

import "../../interfaces/IDiamondCut.sol";
import "../../interfaces/IVaultFacet.sol";
```

This defines imports of libraries, interfaces, storage, and the VaultDiamond to be used in this contract

##### Line 11

```
contract VaultSpawnerFacet is StorageLayout {
```

The contract keyword defines a contract VaultSpawnerFacet which inherits from an abstract contract called StorageLayout that declares a pointer to a FactoryAppStorage which is a container that houses the variables to be used in this contract

##### Line 12

```
event VaultCreated(
    address indexed owner,
    address indexed backup,
    uint256 indexed startingBalance,
    uint256 vaultID
  );
```

This declares an event to be emitted when a new vault is created, emitting the owner of the vaults address, his backup address, his starting balance and the id of the created vault

##### Line 19

```
error BackupAddressError()
```

This defines a custom error message BackupAddressError()

##### Line 21

```
  function createVault(
    address[] calldata _inheritors,
    uint256[] calldata _weiShare,
    uint256 _startingBal,
    address _backupAddress
  ) external payable returns (address addr) {
```

The createvault function is called when a new vault is to created, it is declared as external denoting that it can only be called by an external source and payable
Which enables the contract to receive ether values and returns an address.
It takes in 4 parameters;
An array of inheritors addresses
An array of shares in wei to be ascribed to each inheritor
A starting balance to populate the vault and
A backup address for safety measures

##### Line 27

```
if (_backupAddress == msg.sender){
 revert BackupAddressError();
}
```

This ensures that the address interacting with this function is not the same as the provided address
It reverts with a BackupAddressError if the condition is true

##### Line 30

```
if (_startingBal > 0) {
      assert(_startingBal == msg.value);
    }
```

This line defines a condition that asserts that the starting balance is equivalent to the value coming in from the user if the starting balance is greater than zero

##### Line 33

```
assert(_inheritors.length == _weiShare.length);
```

This line ensures that the length of the inheritors array is equivalent to the length of the array holding the individual weiShare. it reverts if false

##### Line 35 - 42

```
bytes32 entropy = keccak256(
      abi.encode(msg.sender, block.timestamp, fs.VAULTID)
    );
 VaultDiamond vaultAddr = new VaultDiamond{ salt: entropy }(
      fs.diamondCutFacet,
      _backupAddress
    );
addr = address(vaultAddr);
```

This lines deploys an instance of a vaultdiamond to an address (vaultAddr) and ensures that the entropy is unique which is a random 32 byte value generated by hashing the encoded result of msg.sender, block.timestamp and the vaultid, then finally passing the returned address to the variable "addr".

##### Line 46 - 49

```
assert(IVaultDiamond(addr).tempOwner() == tx.origin);
    //deposit startingBal
(bool success, ) = addr.call{ value: _startingBal }("");
    assert(success)
```

asserts that the owner of the deployed vault is an Externally Owned Contract(EOA)
then proceed to deposit a value which is the passed in starting balance which should return a true or false
state depending on the success of the call
then finally ensures that a value of 1(true) is returned else it reverts

## UPGRADING

##### Line 52

```
 IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](6)
```

This line creates a fixed array(length is six) of FacetCut Struct called "cut" as defined in the IDiamondCut interface. This struct is a container for the facetAddress, The action to be performed on that facet and an array of the facet functions to be added to the diamond.

##### Line 53 - 57

```
cut[0] = IDiamondCut.FacetCut({
      facetAddress: fs.erc20Facet,
      action: IDiamondCut.FacetCutAction.Add,
      functionSelectors: fs.ERC20SELECTORS
    })
```

This initializes a struct at index 0 of the cut array, this struct has its facetAddress set to the erc20Facet, together with the functions to be added(an add action, gotten from an enumerable of FacetCutActions which comprises of Add, Replace and Remove actions)

##### Line 58 - 62

```
 cut[1] = IDiamondCut.FacetCut({
      facetAddress: fs.erc721Facet,
      action: IDiamondCut.FacetCutAction.Add,
      functionSelectors: fs.ERC721SELECTORS
    })
```

This initializes a struct at index 1 of the cut array, this struct has its facetAddress set to the erc721Facet, together with the functions to be added(an add action, gotten from an enumerable of FacetCutActions which comprises of Add, Replace and Remove actions)

##### Line 63 - 67

```
 cut[2] = IDiamondCut.FacetCut({
      facetAddress: fs.erc1155Facet,
      action: IDiamondCut.FacetCutAction.Add,
      functionSelectors: fs.ERC1155SELECTORS
    })
```

This initializes a struct at index 2 of the cut array, this struct has its facetAddress set to the erc1155Facet, together with the functions to be added(an add action, gotten from an enumerable of FacetCutActions which comprises of Add, Replace and Remove actions)

##### Line 68 - 72

```
cut[3] = IDiamondCut.FacetCut({
      facetAddress: fs.diamondLoupeFacet,
      action: IDiamondCut.FacetCutAction.Add,
      functionSelectors: fs.DIAMONDLOUPEFACETSELECTORS
    })
```

This initializes a struct at index 3 of the cut array, this struct has its facetAddress set to the diamondLoupeFacet, together with the functions to be added(an add action, gotten from an enumerable of FacetCutActions which comprises of Add, Replace and Remove actions)

##### Line 73 - 77

```
cut[4] = IDiamondCut.FacetCut({
      facetAddress: fs.vaultFacet,
      action: IDiamondCut.FacetCutAction.Add,
      functionSelectors: fs.VAULTFACETSELECTORS
    })
```

This initializes a struct at index 4 of the cut array, this struct has its facetAddress set to the vaultFacet, together with the functions to be added(an add action, gotten from an enumerable of FacetCutActions which comprises of Add, Replace and Remove actions)

##### Line 79 - 83

```
cut[5] = IDiamondCut.FacetCut({
      facetAddress: fs.slotChecker,
      action: IDiamondCut.FacetCutAction.Add,
      functionSelectors: fs.SLOTCHECKERSELECTORS
    })
```

This initializes a struct at index 5 of the cut array, this struct has its facetAddress set to the slotChecker, together with the functions to be added(an add action, gotten from an enumerable of FacetCutActions which comprises of Add, Replace and Remove actions)

##### Line 85

```
IDiamondCut(addr).diamondCut(cut, address(0), "")
```

This performs a call to the diamondCut function using an interface IDiamondCut on the vaultdiamond
passing in an array of FacetCut, a zero address with no calldata. This executes the upgrade

##### 87 - 89

```if (_inheritors.length > 0) {
      IVaultFacet(addr).addInheritors(_inheritors, _weiShare);
    }
```

This line checks to ensure that the number of inheritors passed with the createVault function call is greater than zero.
if the condition is true, the inheritors addresses are added to the array of inheritors as declared in the VaultData storage

##### Line 91 - 92

```
 emit VaultCreated(msg.sender, _backupAddress, _startingBal, fs.VAULTID);
    fs.VAULTID++
```

The vaultCreated event finally emits the msg.sender, the backupAddress, the starting balance and the ID of the Vault.

Finally the Vault ID is incremented by one

## LibKeep.sol

##### Line 3 - 13

```
import {Guards} from "./LibVaultStorage.sol";
import "./LibDiamond.sol";
import "./LibKeepHelpers.sol";
import "../../interfaces/IERC20.sol";

import "../../interfaces/IERC721.sol";

import "../../interfaces/IERC1155.sol";

import "../libraries/LibLayoutSilo.sol";
import "../libraries/LibStorageBinder.sol"
```

This lines declares imports of libraries and interfaces to be used in the libkeep contract

##### Line 15 - 17

```
bytes4 constant ERC1155_ACCEPTED = 0xf23a6e61;
bytes4 constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;
bytes4 constant ERC721WithCall = 0xb88d4fde
```

This lines defines constants of function selectors for ERC1155 and ERC721 token standards
**_Line 15_** assigns the function selector of _onERC1155Received(address,address,uint256,uint256,bytes)_ function signature to the variable declared
**_Line 16_** assigns the function selector of _onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)_ function signature to the variable declared
**_Line 17_** assigns the function selector of _safeTransferFrom(address,address,uint256,bytes)_ function signature to the variable declared. This function makes an extra check to ensure that the recipient is a valid ERC721 receiver contract.

##### Line 19

```
library LibKeep {
```

This line begins the start of the LibKeep Library definition and related internal functions

##### Line 20 - 46

```
    event VaultPinged(uint256 lastPing, uint256 vaultID);
    event InheritorsAdded(address[] newInheritors, uint256 vaultID);
    event InheritorsRemoved(address[] inheritors, uint256 vaultID);
    event EthAllocated(address[] inheritors, uint256[] amounts, uint256 vaultID);

    event ERC20TokenWithdrawal(address token, uint256 amount, address to, uint256 vaultID);

    event ERC721TokenWIthdrawal(address token, uint256 tokenID, address to, uint256 vaultID);
    event ERC1155TokenWithdrawal(address token, uint256 tokenID, uint256 amount, address to, uint256 vaultID);
    event ERC20ErrorHandled(address);
    event ERC721ErrorHandled(uint256 _failedTokenId, string reason);

    event ERC20TokensAllocated(address indexed token, address[] inheritors, uint256[] amounts, uint256 vaultID);
    event ERC721TokensAllocated(address indexed token, address inheritor, uint256 tokenID, uint256 vaultID);
    event ERC1155TokensAllocated(
        address indexed token, address inheritor, uint256 tokenID, uint256 amount, uint256 vaultID
    );
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, uint256 vaultID);
    event BackupTransferred(address indexed previousBackup, address indexed newBackup, uint256 vaultID);
    event EthClaimed(address indexed inheritor, uint256 _amount, uint256 vaultID);

    event ERC20TokensClaimed(address indexed inheritor, address indexed token, uint256 amount, uint256 vaultID);

    event ERC721TokenClaimed(address indexed inheritor, address indexed token, uint256 tokenID, uint256 vaultID);
    event ERC1155TokensClaimed(
        address indexed inheritor, address indexed token, uint256 tokenID, uint256 amount, uint256 vaultID
    )
```

This lines declares events to be emitted with varying function calls as defined in the libkeep library

##### Line 48 - 59

```
  error LengthMismatch();
    error ActiveInheritor();
    error NotEnoughEtherToAllocate(uint256);
    error EmptyArray();
    error NotInheritor();
    error EtherAllocationOverflow(uint256 overflow);
    error TokenAllocationOverflow(address token, uint256 overflow);
    error InactiveInheritor();
    error InsufficientEth();
    error InsufficientTokens();
    error NoAllocatedTokens();
    error NotERC721Owner()
```

This lines declares custom errors to be used in assertions

##### Line 62 - 66

```
 function _ping() internal {
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        vaultData.lastPing = block.timestamp;
        emit VaultPinged(block.timestamp, _vaultID());
    }
```

This function updates the lastPing variable of vaultData in storage with the current block.timestamp whenever the vault storage is modified and it emits an event
VaultPinged() with the current block.timestamp and vaultId.

##### Line 68 - 75

```
function getCurrentAllocatedEth() internal view returns (uint256) {
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        uint256 totalEthAllocated;
        for (uint256 x; x < vaultData.inheritors.length; x++) {
            totalEthAllocated += vaultData.inheritorWeishares[vaultData.inheritors[x]];
        }
        return totalEthAllocated;
    }
```

This function returns a total of all the ETH shares allocated to inheritors in a vault.

##### Line 77 - 84

```
function getCurrentAllocatedTokens(address _token) internal view returns (uint256) {
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        uint256 totalTokensAllocated;
        for (uint256 x; x < vaultData.inheritors.length; x++) {
            totalTokensAllocated += vaultData.inheritorTokenShares[vaultData.inheritors[x]][_token];
        }
        return totalTokensAllocated;
    }
```

This function returns a total of all the token shares for a particular token allocated to inheritors in a vault.

##### Line 86 - 91

```
function getCurrentAllocated1155tokens(address _token, uint256 _tokenID) internal view returns (uint256 alloc_) {
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        for (uint256 x; x < vaultData.inheritors.length; x++) {
            alloc_ += vaultData.inheritorERC1155TokenAllocations[vaultData.inheritors[x]][_token][_tokenID];
        }
    }
```

This function returns a total of all the token shares for a particular ERC1155 allocated to inheritors in a
vault.

##### Line 93 - 96

```
function _vaultID() internal view returns (uint256 vaultID_) {
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        vaultID_ = vaultData.vaultID;
    }
```

This function returns the vault id of a particular vault

##### Line 98 - 114

```
  function _resetClaimed(address _inheritor) internal {
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        vaultData.inheritorWeishares[_inheritor] = 0;
        //resetting all token allocations if he has any
        if (vaultData.inheritorAllocatedERC20Tokens[_inheritor].length > 0) {
            //remove all token addresses
            delete vaultData.inheritorAllocatedERC20Tokens[_inheritor];
        }

        if (vaultData.inheritorAllocatedERC721TokenAddresses[_inheritor].length > 0) {
            delete vaultData.inheritorAllocatedERC721TokenAddresses[_inheritor];
        }

        if (vaultData.inheritorAllocatedERC1155TokenAddresses[_inheritor].length > 0) {
            delete vaultData.inheritorAllocatedERC1155TokenAddresses[_inheritor];
        }
    }
```

This function reset the balances of ETH, ERC721,ERC1155, and ERC20 tokens of an inheritor to zero after they have claimed.

##### Line 117 - 156

```
 function reset(address _inheritor) internal {
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        vaultData.inheritorWeishares[_inheritor] = 0;
        //resetting all token allocations if he has any
        if (vaultData.inheritorAllocatedERC20Tokens[_inheritor].length > 0) {
            for (uint256 x; x < vaultData.inheritorAllocatedERC20Tokens[_inheritor].length; x++) {
                vaultData.inheritorTokenShares[_inheritor][vaultData.inheritorAllocatedERC20Tokens[_inheritor][x]] = 0;
                vaultData.inheritorActiveTokens[_inheritor][vaultData.inheritorAllocatedERC20Tokens[_inheritor][x]] = false;
            }
            //remove all token addresses
            delete vaultData.inheritorAllocatedERC20Tokens[_inheritor];
        }

        if (vaultData.inheritorAllocatedERC721TokenAddresses[_inheritor].length > 0) {
            for (uint256 x; x < vaultData.inheritorAllocatedERC721TokenAddresses[_inheritor].length; x++) {
                address tokenAddress = vaultData.inheritorAllocatedERC721TokenAddresses[_inheritor][x];
                uint256 tokenAllocated = vaultData.inheritorERC721Tokens[_inheritor][tokenAddress];
                if (tokenAllocated == 0) {
                    vaultData.whitelist[tokenAddress][_inheritor] = false;
                }
                vaultData.inheritorERC721Tokens[_inheritor][tokenAddress] = 0;
                vaultData.allocatedERC721Tokens[tokenAddress][tokenAllocated] = false;
                //also reset reverse allocation mapping
                vaultData.ERC721ToInheritor[tokenAddress][tokenAllocated] = address(0);
                delete vaultData.inheritorAllocatedTokenIds[_inheritor][tokenAddress];
            }
            //remove all token addresses
            delete vaultData.inheritorAllocatedERC721TokenAddresses[_inheritor];
        }

        if (vaultData.inheritorAllocatedERC1155TokenAddresses[_inheritor].length > 0) {
            for (uint256 x; x < vaultData.inheritorAllocatedERC1155TokenAddresses[_inheritor].length; x++) {
                vaultData.inheritorERC1155TokenAllocations[_inheritor][vaultData.inheritorAllocatedERC1155TokenAddresses[_inheritor][x]][vaultData
                    .inheritorAllocatedTokenIds[_inheritor][vaultData.inheritorAllocatedERC1155TokenAddresses[_inheritor][x]][x]]
                = 0;
            }

            delete vaultData.inheritorAllocatedERC1155TokenAddresses[_inheritor];
        }
    }
```

This function also reset the balances of ETH, ERC721, ERC1155, and ERC20 tokens of an inheritor but this is only used for multiple address elemented arrays.

##### Line 160 - 188

```
 function _addInheritors(address[] calldata _newInheritors, uint256[] calldata _weiShare) internal {
        if (_newInheritors.length == 0 || _weiShare.length == 0) {
            revert EmptyArray();
        }
        if (_newInheritors.length != _weiShare.length) {
            revert LengthMismatch();
        }
        Guards._notExpired();
        uint256 total;
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        for (uint256 k; k < _newInheritors.length; k++) {
            total += _weiShare[k];

            if (vaultData.activeInheritors[_newInheritors[k]]) {
                revert ActiveInheritor();
            }
            //append the inheritors for a vault
            vaultData.inheritors.push(_newInheritors[k]);
            vaultData.activeInheritors[_newInheritors[k]] = true;
            //   if (total + allocated > address(this).balance)
            //     revert NotEnoughEtherToAllocate(address(this).balance);
            //   vaultData.inheritorWeishares[_newInheritors[k]] = _weiShare[k];
        }
        _allocateEther(_newInheritors, _weiShare);

        _ping();
        emit InheritorsAdded(_newInheritors, _vaultID());
        emit EthAllocated(_newInheritors, _weiShare, _vaultID());
    }
```

This Function Adds inheritors to a vault, with their corresponding Wei balance. it ensures the array of inheritors to be added is not empty, it is guarded with \_notExpired() which reverts the whole adding process if the last ping time is greater than 24 weeks (six months). it calls the \_ping() function after thisoperation to update the lastPing in storage. It also emits two events InheritorsAdded() and EthAllocated();

##### Line 194 - 216

```
 function _allocateEther(address[] calldata _inheritors, uint256[] calldata _ethShares) internal {
        if (_inheritors.length == 0 || _ethShares.length == 0) {
            revert EmptyArray();
        }
        if (_inheritors.length != _ethShares.length) {
            revert LengthMismatch();
        }

        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        for (uint256 k; k < _inheritors.length; k++) {
            if (!Guards._activeInheritor(_inheritors[k])) {
                revert InactiveInheritor();
            }
            // update storage
            vaultData.inheritorWeishares[_inheritors[k]] = _ethShares[k];
            //make sure limit isn't exceeded
            if (getCurrentAllocatedEth() > address(this).balance) {
                revert EtherAllocationOverflow(getCurrentAllocatedEth() - address(this).balance);
            }
        }
        _ping();
        emit EthAllocated(_inheritors, _ethShares, _vaultID());
    }
```

This function allocates ether to inheritors, it first ensures that the array of inheritors is not empty and also that the inheritors array length is same as the length of the array holding their shares in ether. it reverts with the appropriate error message if otherwise. it further chaecks the storage to ensure that the passed in inheritors are indeed active inheritors and also that the cummulative ether allocated is not greater than the ether available in the contract. it updates the last ping to the current block.timestamp then emit the details of the allocated Eth

##### Line 218 - 253

```
   function _allocateERC20Tokens(address token, address[] calldata _inheritors, uint256[] calldata _shares) internal {
        if (_inheritors.length == 0 || _shares.length == 0) {
            revert EmptyArray();
        }
        if (_inheritors.length != _shares.length) {
            revert LengthMismatch();
        }
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        for (uint256 k; k < _inheritors.length; k++) {
            if (!Guards._anInheritor(_inheritors[k])) {
                revert NotInheritor();
            }
            if (!Guards._activeInheritor(_inheritors[k])) {
                revert InactiveInheritor();
            }
            vaultData.inheritorTokenShares[_inheritors[k]][token] = _shares[k];
            if (!vaultData.inheritorActiveTokens[_inheritors[k]][token] && _shares[k] > 0) {
                vaultData.inheritorAllocatedERC20Tokens[_inheritors[k]].push(token);
                vaultData.inheritorActiveTokens[_inheritors[k]][token] = true;
            }
            //if allocation is being reduced to zero
            if (_shares[k] == 0) {
                LibKeepHelpers.removeAddress(vaultData.inheritorAllocatedERC20Tokens[_inheritors[k]], token);
                //double-checking
                vaultData.inheritorActiveTokens[_inheritors[k]][token] = false;
            }
            //finally check that limit isn't exceeded
            //get vault token balance
            uint256 currentBalance = IERC20(token).balanceOf(address(this));
            if (getCurrentAllocatedTokens(token) > currentBalance) {
                revert TokenAllocationOverflow(token, getCurrentAllocatedTokens(token) - currentBalance);
            }
        }
        _ping();
        emit ERC20TokensAllocated(token, _inheritors, _shares, _vaultID());
    }
```

This function allocates ERC20 Tokens to inheritors, it first ensures that the array of inheritors is not empty and also that the inheritors array length is same as the length of the array holding their shares in ether. it reverts with the appropriate error message if otherwise.

it goes further to check if the passed in inheritor is registered and active, checks if the passed in token is part of the inheritors active token and the token share is greater than zero. it this checks are true, pushed this token to the inheritors allocated ERC20 Tokens and set it as an active token.

If the token shares for an inheritor is been reduced to zero, remove that token from the allocated inheritor ERC20 Tokens and set the inheritorActiveTokens for that particular token to false.
finally check and ensure that the cummulative allocated Tokens is greater than the contract balance of that token, update the last ping variable in storage and emit the informations from this function

##### Line 255 - 327

```
    function _allocateERC721Tokens(address _token, address[] calldata _inheritors, uint256[] calldata _tokenIDs)
        internal
    {
        if (_inheritors.length == 0 || _tokenIDs.length == 0) {
            revert EmptyArray();
        }
        if (_inheritors.length != _tokenIDs.length) {
            revert LengthMismatch();
        }
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        for (uint256 k; k < _inheritors.length; k++) {
            if (!Guards._anInheritorOrZero(_inheritors[k])) {
                revert NotInheritor();
            }
            if (!Guards._activeInheritor(_inheritors[k])) {
                revert InactiveInheritor();
            }
            //short-circuit
            if (vaultData.ERC721ToInheritor[_token][_tokenIDs[k]] == _inheritors[k]) {
                continue;
            }
            //confirm ownership
            try IERC721(_token).ownerOf(_tokenIDs[k]) returns (address owner) {
                if (owner == address(this)) {
                    if (vaultData.allocatedERC721Tokens[_token][_tokenIDs[k]]) {
                        address current = vaultData.ERC721ToInheritor[_token][_tokenIDs[k]];
                        //if it is being allocated to someone else
                        if (current != _inheritors[k] && current != address(0) && _inheritors[k] != address(0)) {
                            //Might add an Unallocation event
                            vaultData.whitelist[_token][current] = false;
                            LibKeepHelpers.removeUint(vaultData.inheritorAllocatedTokenIds[current][_token], _tokenIDs[k]);
                            //if no tokens remain for that address
                            if (vaultData.inheritorAllocatedTokenIds[current][_token].length == 0) {
                                //remove the address
                                LibKeepHelpers.removeAddress(vaultData.inheritorAllocatedERC721TokenAddresses[current], _token);
                            }
                        }
                        //if it is being unallocated
                        if (_inheritors[k] == address(0)) {
                            vaultData.allocatedERC721Tokens[_token][_tokenIDs[k]] = false;
                            LibKeepHelpers.removeUint(vaultData.inheritorAllocatedTokenIds[current][_token], _tokenIDs[k]);

                            if (vaultData.inheritorAllocatedTokenIds[_inheritors[k]][_token].length == 0) {
                                LibKeepHelpers.removeAddress(vaultData.inheritorAllocatedERC721TokenAddresses[current], _token);
                            }
                        }
                    } else {
                        vaultData.allocatedERC721Tokens[_token][_tokenIDs[k]] = true;
                    }
                    vaultData.ERC721ToInheritor[_token][_tokenIDs[k]] = _inheritors[k];
                    if (vaultData.inheritorAllocatedTokenIds[_inheritors[k]][_token].length == 0) {
                        vaultData.inheritorAllocatedERC721TokenAddresses[_inheritors[k]].push(_token);
                    }

                    vaultData.inheritorAllocatedTokenIds[_inheritors[k]][_token].push(_tokenIDs[k]);

                    if (_tokenIDs[k] == 0) {
                        vaultData.whitelist[_token][_inheritors[k]] = true;
                    }
                    //   vaultData.inheritorERC721Tokens[_inheritors[k]][_token] = _tokenIDs[k];
                    emit ERC721TokensAllocated(_token, _inheritors[k], _tokenIDs[k], _vaultID());
                }
                if (owner != address(this)) {
                    emit ERC721ErrorHandled(_tokenIDs[k], "Not_Owner");
                    continue;
                }
            } catch Error(string memory r) {
                emit ERC721ErrorHandled(_tokenIDs[k], r);
                continue;
            }
        }
        _ping();
    }
```

This Function sets token allocations for a particular ERC721 for a list of inheritors. it ensures the array of inheritors and array of shears provided have the same length and they are not empty arrays, it is guarded with \_aninheritorOrZero() which returns true
for a true inheritor or a zero address and \_activeInheritor() which returns true for an active
inheritor and false otherwise,

if the caller of this function is not the contract address the process is
reversed with ERC721ErrorHandled() error. It calls the_ping() function after this operation to update the lastPing in storage. It also emits an event ERC721TokensAllocated()

##### Line 329 - 382

```
    function _allocateERC1155Tokens(
        address _token,
        address[] calldata _inheritors,
        uint256[] calldata _tokenIDs,
        uint256[] calldata _amounts
    )
        internal
    {
        if (_inheritors.length == 0 || _tokenIDs.length == 0) {
            revert EmptyArray();
        }
        if (_inheritors.length != _tokenIDs.length) {
            revert LengthMismatch();
        }
        if (_inheritors.length != _amounts.length) {
            revert LengthMismatch();
        }
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        for (uint256 i; i < _inheritors.length; i++) {
            if (!Guards._anInheritor(_inheritors[i])) {
                revert NotInheritor();
            }
            if (!Guards._activeInheritor(_inheritors[i])) {
                revert InactiveInheritor();
            }
            vaultData.inheritorERC1155TokenAllocations[_inheritors[i]][_token][_tokenIDs[i]] = _amounts[i];
            //if id is just being added
            if (!LibKeepHelpers._inUintArray(vaultData.inheritorAllocatedTokenIds[_inheritors[i]][_token], _tokenIDs[i])) {
                vaultData.inheritorAllocatedTokenIds[_inheritors[i]][_token].push(_tokenIDs[i]);
            }
            //if address is just being added
            if (!LibKeepHelpers._inAddressArray(vaultData.inheritorAllocatedERC1155TokenAddresses[_inheritors[i]], _token)) {
                vaultData.inheritorAllocatedERC1155TokenAddresses[_inheritors[i]].push(_token);
            }
            //if tokens are being unallocated
            if (_amounts[i] == 0) {
                LibKeepHelpers.removeUint(vaultData.inheritorAllocatedTokenIds[_inheritors[i]][_token], _tokenIDs[i]);
            }
            //if no tokens for the token address remain
            if (vaultData.inheritorAllocatedTokenIds[_inheritors[i]][_token].length == 0) {
                LibKeepHelpers.removeAddress(vaultData.inheritorAllocatedERC1155TokenAddresses[_inheritors[i]], _token);
            }
            //confirm numbers
            uint256 allocated = getCurrentAllocated1155tokens(_token, _tokenIDs[i]);
            uint256 available = IERC1155(_token).balanceOf(address(this), _tokenIDs[i]);
            if (allocated > available) {
                revert TokenAllocationOverflow(_token, allocated - available);
            }

            emit ERC1155TokensAllocated(_token, _inheritors[i], _tokenIDs[i], _amounts[i], _vaultID());
        }

        _ping();
    }
```

This Function sets token allocations for a particular ERC1155 for a list of inheritors. it ensures the array of inheritors, array of tokenIds and array of amount provided have the same length and they are not empty arrays, it is guarded with \_aninheritor() which returns true for a true inheritor and \_activeInheritor() which returns true for an active inheritor and false
otherwise, if no tokens for the token address remain the token address is removed from the list allocated ERC1155 address.

It calls the \_ping() function after this operation to update the lastPing in storage. It
also emits an event ERC1155TokensAllocated().

##### Line 386 - 398

```
  function _withdrawEth(uint256 _amount, address _to) internal {
        //confirm free eth is sufficient
        uint256 allocated = getCurrentAllocatedEth();
        if (address(this).balance >= allocated) {
            if (address(this).balance - allocated < _amount) {
                revert InsufficientEth();
            }
            (bool success,) = _to.call{value: _amount}("");
            assert(success);
        } else {
            revert InsufficientEth();
        }
    }
```

This function withdraws unallocated eth, else reverts with InsufficientEth error

##### Line 400 - 433

```
 function _withdrawERC20Tokens(address[] calldata _tokenAdds, uint256[] calldata _amounts, address _to) internal {
        if (_tokenAdds.length == 0 || _amounts.length == 0) {
            revert EmptyArray();
        }
        if (_tokenAdds.length != _amounts.length) {
            revert LengthMismatch();
        }
        // VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        for (uint256 x; x < _tokenAdds.length; x++) {
            address token = _tokenAdds[x];
            uint256 amount = _amounts[x];
            uint256 availableTokens = getCurrentAllocatedTokens(token);
            uint256 currentBalance = IERC20(token).balanceOf(address(this));
            bool success;
            if (currentBalance >= availableTokens) {
                if (currentBalance - availableTokens < _amounts[x]) {
                    revert InsufficientTokens();
                }
                //for other errors caused by malformed tokens
                try IERC20(token).transfer(_to, amount) {
                    success;
                } catch {
                    if (success) {
                        emit ERC20TokenWithdrawal(token, amount, _to, _vaultID());
                    } else {
                        emit ERC20ErrorHandled(token);
                    }
                }
            } else {
                revert InsufficientTokens();
            }
        }
        _ping();
    }
```

This function is used to withdraw unallocated ERC20 token

##### Line 435 - 457

```
   function _withdrawERC20Token(address _token, uint256 _amount, address _to) internal {
        uint256 availableTokens = getCurrentAllocatedTokens(_token);
        uint256 currentBalance = IERC20(_token).balanceOf(address(this));
        bool success;
        if (currentBalance >= availableTokens) {
            if (currentBalance - availableTokens < _amount) {
                revert InsufficientTokens();
            }
            try IERC20(_token).transfer(_to, _amount) {
                success;
            } catch {
                if (success) {
                    emit ERC20TokenWithdrawal(_token, _amount, _to, _vaultID());
                } else {
                    emit ERC20ErrorHandled(_token);
                }
            }
        } else {
            revert InsufficientTokens();
        }

        _ping();
    }
```

This function is used to withdraw unallocated ERC20 Tokens

##### Line 459 - 476

```
function _withdrawERC721Token(address _token, uint256 _tokenID, address _to) internal {
        if (IERC721(_token).ownerOf(_tokenID) != address(this)) {
            revert NotERC721Owner();
        }
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        if (vaultData.allocatedERC721Tokens[_token][_tokenID]) {
            revert("UnAllocate Token First");
        }
        try IERC721(_token).safeTransferFrom(address(this), _to, _tokenID) {}
        catch {
            string memory reason;
            if (bytes(reason).length == 0) {
                emit ERC721TokenWIthdrawal(_token, _tokenID, _to, _vaultID());
            } else {
                emit ERC20ErrorHandled(_token);
            }
        }
    }

```

This function is used To withdraw ERC721 Token

##### 478 - 490

```
    function _withdrawERC1155Token(address _token, uint256 _tokenID, uint256 _amount, address _to) internal {
        uint256 allocated = getCurrentAllocated1155tokens(_token, _tokenID);
        uint256 balance = IERC1155(_token).balanceOf(address(this), _tokenID);
        if (balance < _amount) {
            revert InsufficientTokens();
        }

        if (balance - allocated < _amount) {
            revert("UnAllocate TokensFirst");
        }
        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenID, _amount, "");
        emit ERC1155TokenWithdrawal(_token, _tokenID, _amount, _to, _vaultID());
    }

```

This function is used to withdraw ERC1155 Tokens

##### Line 494 - 499

```
  function _transferOwnerShip(address _newOwner) internal {
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        address prevOwner = vaultData.vaultOwner;
        vaultData.vaultOwner = _newOwner;
        emit OwnershipTransferred(prevOwner, _newOwner, _vaultID());
    }
```

This function is used to transfer ownership of vault. it does so by taking in a new owner address as input and set it as the new vault owner address in storage. it emits an ownershipTransferred event

##### Line 501 - 506

```
function _transferBackup(address _newBackupAddress) internal {
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        address prevBackup = vaultData.backupAddress;
        vaultData.backupAddress = _newBackupAddress;
        emit BackupTransferred(prevBackup, _newBackupAddress, _vaultID());
    }
```

This function updates the backup address in storage to the new address coming in as input.
it emits a BackupTransferred event

##### Line 510 - 520

```
 function _claimOwnership(address _newBackup) internal {
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        Guards._expired();
        address prevOwner = vaultData.vaultOwner;
        address prevBackup = vaultData.backupAddress;
        assert(prevOwner != _newBackup);
        vaultData.vaultOwner = msg.sender;
        vaultData.backupAddress = _newBackup;
        emit OwnershipTransferred(prevOwner, msg.sender, _vaultID());
        emit BackupTransferred(prevBackup, _newBackup, _vaultID());
    }
```

This function allows a backup address to claim ownership of a vault with the condition that the vault has reached expiry ie the last ping of the vault is up to or more than 6 months

##### Line 522 - 543

```
function _claimERC20Tokens() internal {
        // Guards._anInheritor(msg.sender);
        // Guards._activeInheritor(msg.sender);
        // Guards._expired();
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        uint256 tokens = vaultData.inheritorAllocatedERC20Tokens[msg.sender].length;
        if (tokens > 0) {
            for (uint256 i; i < tokens; i++) {
                address token = vaultData.inheritorAllocatedERC20Tokens[msg.sender][i];
                if (token == address(0)) {
                    continue;
                }
                uint256 amountToClaim = vaultData.inheritorTokenShares[msg.sender][token];
                if (amountToClaim > 0) {
                    //reset storage
                    vaultData.inheritorTokenShares[msg.sender][token] = 0;
                    IERC20(token).transfer(msg.sender, amountToClaim);
                    emit ERC20TokensClaimed(msg.sender, token, amountToClaim, _vaultID());
                }
            }
        }
    }
```

This function helps inheritors to claim the erc20 tokens allotted to them.

##### Line 547 - 577

```
    function _claimERC721Tokens() internal {
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        uint256 tokens = vaultData.inheritorAllocatedERC721TokenAddresses[msg.sender].length;
        if (tokens > 0) {
            for (uint256 i; i < tokens; i++) {
                address token = vaultData.inheritorAllocatedERC721TokenAddresses[msg.sender][i];
                if (token == address(0)) {
                    continue;
                }
                uint256 tokensToClaim = vaultData.inheritorAllocatedTokenIds[msg.sender][token].length;
                if (tokensToClaim > 0) {
                    for (uint256 j; j < tokensToClaim; j++) {
                        uint256 tokenID = vaultData.inheritorAllocatedTokenIds[msg.sender][token][j];
                        if (tokenID == 0) {
                            //check for whitelist
                            if (vaultData.whitelist[token][msg.sender]) {
                                vaultData.whitelist[token][msg.sender] = false;
                                IERC721(token).transferFrom(address(this), msg.sender, 0);
                                emit ERC721TokenClaimed(msg.sender, token, 0, _vaultID());
                            }
                        } else {
                            //test thorougly for array overflows
                            vaultData.inheritorAllocatedTokenIds[msg.sender][token][j] = 0;
                            IERC721(token).transferFrom(address(this), msg.sender, tokenID);
                            emit ERC721TokenClaimed(msg.sender, token, tokenID, _vaultID());
                        }
                    }
                }
            }
        }
    }
```

This function helps inheritors to claim the ERC721 tokens allotted to them.

##### Line 579 - 602

```
 function _claimERC1155Tokens() internal {
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        uint256 tokens = vaultData.inheritorAllocatedERC1155TokenAddresses[msg.sender].length;
        if (tokens > 0) {
            for (uint256 i; i < tokens; i++) {
                address token = vaultData.inheritorAllocatedERC1155TokenAddresses[msg.sender][i];
                if (token == address(0)) {
                    continue;
                }
                uint256 noOfTokenIds = vaultData.inheritorAllocatedTokenIds[msg.sender][token].length;
                if (noOfTokenIds > 0) {
                    for (uint256 k; k < noOfTokenIds; k++) {
                        uint256 tokenID = vaultData.inheritorAllocatedTokenIds[msg.sender][token][k];
                        uint256 amount = vaultData.inheritorERC1155TokenAllocations[msg.sender][token][tokenID];
                        if (amount > 0) {
                            vaultData.inheritorERC1155TokenAllocations[msg.sender][token][tokenID] = 0;
                            IERC1155(token).safeTransferFrom(address(this), msg.sender, tokenID, amount, "");
                            emit ERC1155TokensClaimed(msg.sender, token, 1, amount, _vaultID());
                        }
                    }
                }
            }
        }
    }
```

This function helps inheritors to claim the ERC1155 tokens allotted to them

##### Line 604 - 618

```
 function _claimAll() internal {
        Guards._anInheritor(msg.sender);
        Guards._activeInheritor(msg.sender);
        Guards._expired();
        Guards._notClaimed(msg.sender);
        VaultData storage vaultData=LibStorageBinder._bindAndReturnVaultStorage();
        if (vaultData.inheritorWeishares[msg.sender] > 0) {
            uint256 amountToClaim = vaultData.inheritorWeishares[msg.sender];
            //reset storage
            vaultData.inheritorWeishares[msg.sender] == 0;
            (bool success,) = msg.sender.call{value: amountToClaim}("");
            assert(success);

            emit EthClaimed(msg.sender, amountToClaim, _vaultID());
        }
```

This function helps inheritors to claim all asset allotted to them

##### Line 620 - 630

```
 _claimERC20Tokens();
        //claim ERC721 Tokens if any
        _claimERC721Tokens();
        //claim ERC1155 Tokens if any
        _claimERC1155Tokens();

        //cleanup
        LibKeepHelpers.removeAddress(vaultData.inheritors, msg.sender);
        //clear storage
        //test thorougly
        _resetClaimed(msg.sender);
```

This line calls the actual functions as described
